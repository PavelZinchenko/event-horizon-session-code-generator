<#@ template language="C#" #>
<#@ import namespace="Schema" #><#+

private string ConvertType(string type, DataSchema schema)
{
	if (type == Constants.TypeInt)
	{
		return "int";
	}
	else if (type == Constants.TypeUint)
	{
		return "uint";
	}
	else if (type == Constants.TypeLong)
	{
		return "long";
	}
	else if (type == Constants.TypeUlong)
	{
		return "ulong";
	}
	else if (type == Constants.TypeShort)
	{
		return "short";
	}
	else if (type == Constants.TypeUshort)
	{
		return "ushort";
	}
	else if (type == Constants.TypeSbyte)
	{
		return "sbyte";
	}
	else if (type == Constants.TypeByte)
	{
		return "byte";
	}
	else if (type == Constants.TypeFloat)
	{
		return "float";
	}
	else if (type == Constants.TypeBool)
	{
		return "bool";
	}
	else if (type == Constants.TypeString)
	{
		return "string";
	}
	else if (schema.HasObject(type))
	{
		return type;
	}
	else if (schema.HasStruct(type))
	{
		return type;
	}
	else
	{
		throw new InvalidSchemaException("Invalid type - " + type);
	}
}

private void WriteInterfaceProperty(XmlClassMember member, DataSchema schema)
{
	var propertyName = Utils.PropertyName(member.name);
	var memberName = Utils.PrivateMemberName(member.name);

	if (member.type == Constants.TypeMap)
	{
		var key = ConvertType(member.key, schema);
		var value = ConvertType(member.value, schema);
		WriteLine($"public {Utils.MapType}<{key}, {value}> {propertyName} {{ get; }}");
	}
	else if (member.type == Constants.TypeSet)
	{
		WriteLine($"public {Utils.SetType}<{ConvertType(member.value, schema)}> {propertyName} {{ get; }}");
	}
	else if (member.type == Constants.TypeList)
	{
		WriteLine($"public {Utils.ListType}<{ConvertType(member.value, schema)}> {propertyName} {{ get; }}");
	}
	else if (member.type == Constants.TypeInventory)
	{
		WriteLine($"public {Utils.InventoryType}<{ConvertType(member.value, schema)}> {propertyName} {{ get; }}");
	}
	else if (schema.HasObject(member.type))
	{
		WriteLine($"public {Utils.InterfaceName(member.type)} {propertyName} {{ get; }}");
	}
	else
	{
		WriteLine($"public {ConvertType(member.type, schema)} {propertyName} {{ get; set; }}");
	}
}

private void WriteProperty(XmlClassMember member, DataSchema schema, bool readOnly)
{
	var propertyName = Utils.PropertyName(member.name);
	var memberName = Utils.PrivateMemberName(member.name);
	var notify = !member.options.Contains(Constants.OptionNotImportant);

	if (member.type == Constants.TypeMap)
	{
		WriteLine($"public {Utils.MapType}<{ConvertType(member.key, schema)}, {ConvertType(member.value, schema)}> {propertyName} => {memberName};");
	}
	else if (member.type == Constants.TypeSet)
	{
		WriteLine($"public {Utils.SetType}<{ConvertType(member.value, schema)}> {propertyName} => {memberName};");
	}
	else if (member.type == Constants.TypeList)
	{
		WriteLine($"public {Utils.ListType}<{ConvertType(member.value, schema)}> {propertyName} => {memberName};");
	}
	else if (member.type == Constants.TypeInventory)
	{
		WriteLine($"public {Utils.InventoryType}<{ConvertType(member.value, schema)}> {propertyName} => {memberName};");
	}
	else if (schema.HasObject(member.type))
	{
		WriteLine($"public {member.type} {propertyName} => {memberName};");
	}
	else if (readOnly)
	{
		WriteLine($"public {ConvertType(member.type, schema)} {propertyName} => {memberName};");
	}
	else
	{
		WriteLine($"public {ConvertType(member.type, schema)} {propertyName}");
		WriteLine("{");
		PushIndent("\t");
		WriteLine($"get => {memberName};");
		WriteLine("set");
		WriteLine("{");
		PushIndent("\t");
		WriteLine($"if ({memberName} == value) return;");
		WriteLine($"{memberName} = value;");
		if (notify) WriteLine(Utils.CallbackMethod + "();");
		PopIndent();
		WriteLine("}");
		PopIndent();
		WriteLine("}");
	}
}

private void WriteInitializer(XmlClassMember member, DataSchema schema, string callback)
{
	var memberName = Utils.PrivateMemberName(member.name);

	if (member.type == Constants.TypeMap)
	{
		WriteLine($"{memberName} = new {Utils.MapType}<{ConvertType(member.key, schema)}, {ConvertType(member.value, schema)}>({callback});");
	}
	else if (member.type == Constants.TypeSet)
	{
		WriteLine($"{memberName} = new {Utils.SetType}<{ConvertType(member.value, schema)}>({callback});");
	}
	else if (member.type == Constants.TypeList)
	{
		WriteLine($"{memberName} = new {Utils.ListType}<{ConvertType(member.value, schema)}>({callback});");
	}
	else if (member.type == Constants.TypeInventory)
	{
		WriteLine($"{memberName} = new {Utils.InventoryType}<{ConvertType(member.value, schema)}>({callback});");
	}
	else if (schema.HasObject(member.type))
	{
		WriteLine($"{memberName} = new {member.type}({callback});");
	}
	else if (schema.HasStruct(member.type))
	{
		WriteLine($"{memberName} = new {member.type}({callback});");
	}
	else
	{
		WriteLine($"{memberName} = {GetDefaultValue(member.@default, member.type, schema)};");
	}
}

private string GetDefaultValue(string value, string type, DataSchema schema)
{
	if (type == Constants.TypeString)
		return string.IsNullOrEmpty(value) ? "string.Empty" : $"\"{value}\"";

	if (string.IsNullOrEmpty(value))
		return $"default({ConvertType(type, schema)})";

	if (value == Constants.Timestamp)
		return $"({ConvertType(type, schema)})System.DateTime.UtcNow.Ticks";

	return value;
}

private void WriteClassMember(XmlClassMember member, DataSchema schema, bool readOnly)
{
	var memberName = Utils.PrivateMemberName(member.name);
	var encrypted = member.options.Contains(Constants.OptionEncrypted);
	var prefix = readOnly ? "private readonly " : "private ";
	var suffix = ";";

	string memberType;
	if (member.type == Constants.TypeMap)
	{
		memberType = $"{Utils.MapType}<{ConvertType(member.key, schema)}, {ConvertType(member.value, schema)}>";
	}
	else if (member.type == Constants.TypeSet)
	{
		memberType = $"{Utils.SetType}<{ConvertType(member.value, schema)}>";
	}
	else if (member.type == Constants.TypeList)
	{
		memberType = $"{Utils.ListType}<{ConvertType(member.value, schema)}>";
	}
	else if (member.type == Constants.TypeInventory)
	{
		memberType = $"{Utils.InventoryType}<{ConvertType(member.value, schema)}>";
	}
	else if (encrypted)
	{
		if (member.type == Constants.TypeInt)
			memberType = Utils.EncryptedIntType;
		else if (member.type == Constants.TypeLong)
			memberType = Utils.EncryptedLongType;
		else
			throw new System.InvalidOperationException($"'encrypted' not supported for type {member.type}");
	}
	else
	{
		memberType = ConvertType(member.type, schema);
	}

	WriteLine(prefix + memberType + " " + memberName + suffix);
}

#>